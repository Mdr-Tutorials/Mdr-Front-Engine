# 使用 CodeMirror 作为代码编辑器

## 决策背景

在 MDR Front Engine 项目中，我们需要一个功能强大、可扩展的代码编辑器来支持 MIR 语言的编辑、语法高亮、自动补全等功能。经过调研，我们考虑了以下几个选项：

### 候选方案

1. **CodeMirror 6**
   - 现代化架构，基于模块化设计
   - 优秀的性能表现
   - 丰富的扩展生态系统
   - 活跃的社区支持

2. **Monaco Editor**
   - VS Code 的核心编辑器
   - 功能极其丰富
   - 但体积较大，加载较慢
   - 更适合桌面应用

3. **Ace Editor**
   - 老牌编辑器，功能稳定
   - 但架构相对老旧
   - 社区活跃度下降

4. **自建编辑器**
   - 完全定制化
   - 但开发成本极高
   - 维护负担重

## 决策分析

### CodeMirror 6 的优势

#### 1. 模块化架构
- 核心功能与扩展功能分离
- 按需加载，减少包体积
- 易于定制和维护

#### 2. 优秀的性能
- 虚拟化渲染，处理大文件能力强
- 增量更新机制
- 内存占用合理

#### 3. 强大的扩展性
- 丰富的官方扩展包
- 完善的 API 设计
- 支持自定义语言模式

#### 4. 活跃的生态
- 持续更新维护
- 社区贡献丰富
- 文档完善

### 技术实现

#### 核心模块选择
```typescript
// 基础编辑功能
import { EditorState, EditorView, basicSetup } from '@codemirror/basic-setup';

// 语言支持
import { StreamLanguage } from '@codemirror/stream-parser';
import { mirLanguage } from './mir-language';

// 主题和样式
import { oneDark } from '@codemirror/theme-one-dark';
import { EditorTheme } from './editor-theme';

// 扩展功能
import { autocompletion } from '@codemirror/autocomplete';
import { lintGutter } from '@codemirror/lint';
import { searchKeymap } from '@codemirror/search';
```

#### 自定义语言模式
```typescript
export const mirLanguage = StreamLanguage.define({
  name: 'mir',
  token: (stream) => {
    // MIR 语法高亮逻辑
    if (stream.match(/^\$[a-zA-Z_]\w*/)) return 'variable';
    if (stream.match(/^@[a-zA-Z_]\w*/)) return 'node';
    if (stream.match(/^(input|output|process|condition)\b/)) return 'keyword';
    // ... 更多语法规则
    stream.next();
    return null;
  }
});
```

#### 扩展配置
```typescript
const extensions = [
  basicSetup,
  mirLanguage(),
  EditorTheme,
  autocompletion({
    override: [mirCompletion]
  }),
  lintGutter(),
  searchKeymap,
  // 自定义扩展
  breakpointGutter,
  nodeHighlight,
  variableInspector
];
```

### 集成方案

#### 1. 基础编辑器封装
```typescript
export class MdrEditor {
  private view: EditorView;
  private state: EditorState;
  
  constructor(container: HTMLElement, options: EditorOptions) {
    this.state = EditorState.create({
      doc: options.initialContent,
      extensions: this.createExtensions(options)
    });
    
    this.view = new EditorView({
      state: this.state,
      parent: container
    });
  }
  
  private createExtensions(options: EditorOptions): Extension[] {
    return [
      ...baseExtensions,
      ...(options.readOnly ? [EditorState.readOnly.of(true)] : []),
      ...(options.theme ? [options.theme] : [])
    ];
  }
}
```

#### 2. 调试功能集成
```typescript
// 断点管理
const breakpointExtension = ViewPlugin.fromClass(
  class BreakpointPlugin {
    constructor(view: EditorView) {
      this.decorations = this.computeDecorations(view);
    }
    
    computeDecorations(view: EditorView) {
      // 计算断点装饰
      return Decoration.set(breakpoints.map(bp => {
        return Decoration.widget({
          widget: new BreakpointWidget(bp),
          side: 1
        }).range(bp.position);
      }));
    }
  }
);
```

#### 3. 状态同步
```typescript
// 与调试器状态同步
export function createDebugExtension(debugger: MdrDebugger) {
  return ViewPlugin.fromClass(
    class DebugPlugin implements PluginValue {
      constructor(view: EditorView) {
        this.subscriptions = [
          debugger.on('breakpointChange', () => this.updateDecorations()),
          debugger.on('executionPause', (location) => this.highlightLine(location)),
          debugger.on('variableUpdate', (vars) => this.updateVariableDecorations(vars))
        ];
      }
      
      destroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
      }
    }
  );
}
```

## 性能优化

### 1. 按需加载
```typescript
// 动态导入编辑器模块
const loadEditor = async () => {
  const [{ EditorView }, { basicSetup }] = await Promise.all([
    import('@codemirror/view'),
    import('@codemirror/basic-setup')
  ]);
  return { EditorView, basicSetup };
};
```

### 2. 虚拟化渲染
- 只渲染可视区域的代码
- 处理大文件时保持流畅
- 内存使用优化

### 3. 增量更新
- 最小化 DOM 操作
- 智能 diff 算法
- 状态管理优化

## 扩展功能

### 1. 语法检查
```typescript
// 集成 MIR 语法验证器
const mirLinter = linter((view) => {
  const diagnostics: Diagnostic[] = [];
  const code = view.state.doc.toString();
  
  try {
    validateMirCode(code);
  } catch (error) {
    diagnostics.push({
      from: error.position.start,
      to: error.position.end,
      severity: 'error',
      message: error.message
    });
  }
  
  return diagnostics;
});
```

### 2. 智能提示
```typescript
// MIR 特定自动补全
const mirCompletion = completeFromList([
  { label: 'input', type: 'keyword', info: 'Define input node' },
  { label: 'output', type: 'keyword', info: 'Define output node' },
  { label: 'process', type: 'keyword', info: 'Define process node' },
  { label: 'condition', type: 'keyword', info: 'Define condition node' },
  // ... 更多补全项
]);
```

### 3. 代码折叠
```typescript
// 基于节点结构的代码折叠
const mirFold = foldService.compute(['this'], (state, from, to) => {
  // 识别 MIR 节点结构
  const nodes = findMirNodes(state.doc, from, to);
  return nodes.map(node => ({
    from: node.start,
    to: node.end
  }));
});
```

## 决策结论

选择 **CodeMirror 6** 作为 MDR Front Engine 的代码编辑器，基于以下原因：

### ✅ 优势
1. **现代化架构** - 模块化设计，易于维护和扩展
2. **优秀性能** - 虚拟化渲染，处理大文件能力强
3. **丰富生态** - 官方扩展完善，社区活跃
4. **定制化能力** - 支持深度定制，满足 MIR 语言特殊需求
5. **轻量级** - 按需加载，包体积可控

### ⚠️ 注意事项
1. **学习成本** - 需要理解其插件系统和状态管理
2. **版本更新** - 需要跟进版本更新，确保兼容性
3. **自定义开发** - 某些高级功能需要自行开发扩展

## 后续计划

1. **第一阶段** - 基础编辑器集成，支持语法高亮和基本编辑功能
2. **第二阶段** - 添加调试功能，包括断点、变量查看等
3. **第三阶段** - 智能提示和语法检查，提升开发体验
4. **第四阶段** - 性能优化和高级功能，如代码折叠、搜索替换等

## 参考资料

- [CodeMirror 6 官方文档](https://codemirror.net/6/)
- [CodeMirror 6 架构设计](https://codemirror.net/6/docs/architecture/)
- [CodeMirror 6 扩展开发指南](https://codemirror.net/6/docs/ref/)
- [MIR 语言规范](../mir/MIR-v1.0.json)