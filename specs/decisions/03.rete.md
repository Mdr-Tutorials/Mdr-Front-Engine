# 使用 Rete.js 作为节点图编辑器

## 决策背景

在 MDR Front Engine 项目中，我们需要一个强大的节点图编辑器来支持 MIR 语言的图形化编程。节点图需要支持拖拽连接、实时执行、调试等功能。经过调研，我们考虑了以下几个选项：

### 候选方案

1. **Rete.js**
   - 专门用于创建节点编辑器的框架
   - 模块化架构，易于扩展
   - 活跃的社区和生态系统
   - 支持多种渲染引擎

2. **React Flow**
   - 基于 React 的流程图库
   - 现代化的 API 设计
   - 丰富的内置功能
   - 但主要专注于流程图，对节点编程支持有限

3. **Drawflow**
   - 轻量级的节点编辑器
   - 简单易用
   - 但功能相对基础，扩展性有限

4. **自建节点编辑器**
   - 完全定制化
   - 但开发成本极高
   - 需要处理复杂的图形算法

## 决策分析

### Rete.js 的核心优势

#### 1. 专为节点编程设计
```typescript
// Rete.js 的核心概念完美匹配我们的需求
interface Node {
  id: string;
  type: string;
  inputs: Map<string, Input>;
  outputs: Map<string, Output>;
  controls: Map<string, Control>;
  data: Record<string, any>;
}

interface Connection {
  id: string;
  source: string;
  target: string;
  sourceOutput: string;
  targetInput: string;
}
```

#### 2. 模块化架构
```typescript
// 引擎核心
import { Engine, Component } from 'rete';

// 渲染引擎
import { ReactRenderPlugin } from 'rete-react-render-plugin';
import { AreaPlugin } from 'rete-area-plugin';

// 连接管理
import { ConnectionPlugin } from 'rete-connection-plugin';

// 模块系统
import { ModulePlugin } from 'rete-module-plugin';

// 上下文菜单
import { ContextMenuPlugin } from 'rete-context-menu-plugin';
```

#### 3. 数据流处理
Rete.js 内置了强大的数据流处理机制，完美支持 MIR 的执行模型：

```typescript
class ProcessComponent extends Component {
  constructor() {
    super('Process');
  }

  async builder(node) {
    node
      .addInput(new Input('input', 'Input'))
      .addOutput(new Output('output', 'Output'))
      .addControl(new Control('code', {
        type: 'code',
        language: 'javascript'
      }));
  }

  async worker(node, inputs, outputs) {
    const inputData = inputs['input'][0];
    const code = node.data.code;
    
    // 执行处理逻辑
    const result = await executeCode(code, inputData);
    
    outputs['output'] = result;
  }
}
```

### 技术实现方案

#### 1. 引擎架构设计
```typescript
export class MdrReteEngine {
  private engine: Engine;
  private editor: NodeEditor;
  private components: Map<string, Component>;
  
  constructor(container: HTMLElement) {
    this.engine = new Engine('mdr@0.1.0');
    this.editor = new NodeEditor('mdr@0.1.0', container);
    this.components = new Map();
    
    this.initializePlugins();
    this.registerComponents();
  }

  private initializePlugins() {
    // 区域插件 - 管理画布
    const area = new AreaPlugin(container);
    
    // 连接插件 - 管理节点连接
    const connection = new ConnectionPlugin();
    
    // React 渲染插件
    const render = new ReactRenderPlugin({
      component: CustomNodeComponent
    });
    
    // 上下文菜单
    const contextMenu = new ContextMenuPlugin({
      items: this.getContextMenuItems()
    });
    
    // 模块插件 - 支持子图
    const modules = new ModulePlugin({
      engine: this.engine
    });

    this.editor.use(area);
    this.editor.use(connection);
    this.editor.use(render);
    this.editor.use(contextMenu);
    this.editor.use(modules);
  }

  private registerComponents() {
    // 注册 MIR 节点组件
    const components = [
      new InputComponent(),
      new OutputComponent(),
      new ProcessComponent(),
      new ConditionComponent(),
      new HttpRequestComponent(),
      new VariableComponent()
    ];

    components.forEach(comp => {
      this.components.set(comp.name, comp);
      this.editor.register(comp);
      this.engine.register(comp);
    });
  }
}
```

#### 2. 自定义节点组件
```typescript
// MIR 输入节点
export class InputComponent extends Component {
  constructor() {
    super('Input');
  }

  async builder(node: Node) {
    const out = new Output('output', 'Output', SocketTypes.ANY);
    
    node
      .addOutput(out)
      .addControl(new TextControl('name', {
        label: 'Input Name',
        placeholder: 'Enter input name'
      }))
      .addControl(new SelectControl('type', {
        label: 'Data Type',
        options: ['string', 'number', 'boolean', 'object', 'array']
      }))
      .addControl(new TextControl('default', {
        label: 'Default Value',
        placeholder: 'Optional default value'
      }));
  }

  async worker(node: Node, inputs: any, outputs: any) {
    const inputName = node.data.name;
    const inputType = node.data.type;
    const defaultValue = node.data.default;
    
    // 从执行上下文中获取输入值
    const context = this.getExecutionContext();
    const value = context.getInput(inputName) ?? defaultValue;
    
    // 类型验证
    if (!this.validateType(value, inputType)) {
      throw new Error(`Input ${inputName} type mismatch. Expected ${inputType}, got ${typeof value}`);
    }
    
    outputs['output'] = value;
  }
}

// HTTP 请求节点
export class HttpRequestComponent extends Component {
  constructor() {
    super('HTTP Request');
  }

  async builder(node: Node) {
    node
      .addInput(new Input('url', 'URL', SocketTypes.STRING))
      .addInput(new Input('method', 'Method', SocketTypes.STRING))
      .addInput(new Input('headers', 'Headers', SocketTypes.OBJECT))
      .addInput(new Input('body', 'Body', SocketTypes.ANY))
      .addOutput(new Output('response', 'Response', SocketTypes.OBJECT))
      .addOutput(new Output('error', 'Error', SocketTypes.OBJECT));
  }

  async worker(node: Node, inputs: any, outputs: any) {
    const url = inputs['url']?.[0] ?? node.data.url;
    const method = inputs['method']?.[0] ?? node.data.method ?? 'GET';
    const headers = inputs['headers']?.[0] ?? node.data.headers ?? {};
    const body = inputs['body']?.[0] ?? node.data.body;

    try {
      const response = await fetch(url, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined
      });

      const data = await response.json();
      
      outputs['response'] = {
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        data
      };
    } catch (error) {
      outputs['error'] = {
        message: error.message,
        type: error.constructor.name
      };
    }
  }
}
```

#### 3. 调试功能集成
```typescript
// 调试器插件
export class DebugPlugin extends Plugin {
  private breakpoints: Set<string> = new Set();
  private executionStack: ExecutionFrame[] = [];
  private variableInspector: VariableInspector;

  constructor(private debugger: MdrDebugger) {
    super('debug');
  }

  async install(editor: NodeEditor) {
    // 注册调试相关的事件处理
    editor.on('nodecreate', (node) => this.onNodeCreate(node));
    editor.on('noderemove', (node) => this.onNodeRemove(node));
    editor.on('connectioncreate', (connection) => this.onConnectionCreate(connection));
    
    // 集成断点功能
    this.setupBreakpoints(editor);
    
    // 设置变量查看器
    this.variableInspector = new VariableInspector(editor);
  }

  private setupBreakpoints(editor: NodeEditor) {
    // 在节点上添加断点控件
    editor.on('nodecreate', (node) => {
      const breakpointControl = new BreakpointControl('breakpoint', {
        label: 'Breakpoint',
        onToggle: (enabled) => {
          if (enabled) {
            this.breakpoints.add(node.id);
            this.debugger.addBreakpoint(node.id);
          } else {
            this.breakpoints.delete(node.id);
            this.debugger.removeBreakpoint(node.id);
          }
        }
      });
      
      node.addControl(breakpointControl);
    });
  }

  // 执行控制
  async execute(nodeId: string, context: ExecutionContext) {
    if (this.breakpoints.has(nodeId)) {
      // 触发断点
      await this.debugger.pause(nodeId, context);
    }
    
    // 更新变量查看器
    this.variableInspector.update(context);
    
    // 记录执行历史
    this.executionStack.push({
      nodeId,
      timestamp: Date.now(),
      context: { ...context }
    });
  }
}
```

#### 4. 状态管理集成
```typescript
// 与 MIR 状态管理集成
export class StateSyncPlugin extends Plugin {
  constructor(private mirEngine: MIREngine) {
    super('state-sync');
  }

  async install(editor: NodeEditor) {
    // 监听节点变化
    editor.on('nodeupdate', async (node) => {
      // 同步到 MIR AST
      const mirNode = this.convertToMirNode(node);
      await this.mirEngine.updateNode(mirNode);
    });

    // 监听连接变化
    editor.on('connectioncreate connectionremove', async () => {
      // 更新 MIR 连接关系
      const connections = editor.toJSON().connections;
      await this.mirEngine.updateConnections(connections);
    });
  }

  private convertToMirNode(node: Node): MIRNode {
    return {
      id: node.id,
      type: node.name,
      data: node.data,
      inputs: Array.from(node.inputs.values()).map(input => ({
        name: input.key,
        type: input.socket.name,
        connections: input.connections.map(conn => ({
          nodeId: conn.node.id,
          output: conn.output
        }))
      })),
      outputs: Array.from(node.outputs.values()).map(output => ({
        name: output.key,
        type: output.socket.name,
        connections: output.connections.map(conn => ({
          nodeId: conn.node.id,
          input: conn.input
        }))
      }))
    };
  }
}
```

## 性能优化策略

### 1. 虚拟化渲染
```typescript
// 只渲染可视区域内的节点
const VirtualizationPlugin = (viewport: Viewport) => ({
  install(editor: NodeEditor) {
    editor.on('render', (node) => {
      const bounds = node.getBounds();
      const visible = viewport.isVisible(bounds);
      
      if (!visible) {
        node.element.style.display = 'none';
      } else {
        node.element.style.display = '';
      }
    });
  }
});
```

### 2. 批量更新
```typescript
// 批量处理节点更新
class BatchUpdatePlugin {
  private updateQueue: Node[] = [];
  private updateTimer: number | null = null;

  scheduleUpdate(node: Node) {
    this.updateQueue.push(node);
    
    if (!this.updateTimer) {
      this.updateTimer = requestAnimationFrame(() => {
        this.processBatch();
      });
    }
  }

  private processBatch() {
    const nodes = [...this.updateQueue];
    this.updateQueue = [];
    this.updateTimer = null;

    // 批量更新节点
    nodes.forEach(node => this.updateNode(node));
  }
}
```

### 3. 内存管理
```typescript
// 自动清理未使用的资源
class MemoryManager {
  private nodePool: Map<string, Node> = new Map();
  private lastAccess: Map<string, number> = new Map();

  acquireNode(type: string): Node {
    const key = `${type}-${Date.now()}`;
    
    if (this.nodePool.has(type)) {
      const node = this.nodePool.get(type)!;
      this.nodePool.delete(type);
      return node;
    }

    return this.createNode(type);
  }

  releaseNode(node: Node) {
    this.nodePool.set(node.id, node);
    this.lastAccess.set(node.id, Date.now());
    
    // 延迟清理
    setTimeout(() => {
      if (Date.now() - this.lastAccess.get(node.id)! > 30000) {
        this.nodePool.delete(node.id);
        this.lastAccess.delete(node.id);
        this.destroyNode(node);
      }
    }, 30000);
  }
}
```

## 决策结论

选择 **Rete.js** 作为 MDR Front Engine 的节点图编辑器，基于以下原因：

### ✅ 核心优势
1. **专业性强** - 专门为节点编程设计，概念模型匹配度高
2. **架构优秀** - 模块化设计，易于扩展和维护
3. **生态丰富** - 插件系统完善，社区活跃
4. **性能良好** - 支持虚拟化，处理复杂图能力强
5. **渲染灵活** - 支持多种渲染引擎，易于定制

### ⚠️ 注意事项
1. **学习成本** - 需要理解其插件架构和数据流模型
2. **体积考虑** - 功能丰富但包体积相对较大
3. **版本兼容** - 需要跟进版本更新，注意 API 变化

## 后续开发计划

### 第一阶段：基础集成
- [ ] 核心编辑器集成
- [ ] 基础 MIR 节点实现
- [ ] 连接管理功能
- [ ] 简单的执行引擎

### 第二阶段：调试功能
- [ ] 断点系统集成
- [ ] 变量查看器
- [ ] 执行历史追踪
- [ ] 性能分析工具

### 第三阶段：高级功能
- [ ] 模块化和子图支持
- [ ] 实时协作编辑
- [ ] 高级布局和自动排列
- [ ] 导入导出功能

### 第四阶段：优化完善
- [ ] 性能深度优化
- [ ] 用户体验改进
- [ ] 文档和教程完善
- [ ] 社区插件生态

## 参考资料

- [Rete.js 官方文档](https://rete.js.org/)
- [Rete.js GitHub 仓库](https://github.com/retejs/rete)
- [Rete.js 插件开发指南](https://rete.js.org/docs/guides/plugins)
- [节点编辑器设计模式](https://nodered.org/docs/creating-nodes/)