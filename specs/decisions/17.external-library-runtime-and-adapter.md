# 外部组件库接入（External Library Runtime + Adapter）决策

## 状态

- Draft
- 日期：2026-02-15
- 执行状态：In Progress（2026-02-17）
- 执行计划：`specs/implementation/external-library-execution-plan.md`
- 任务清单：`specs/implementation/external-library-task-backlog.md`
- 生成规范：`specs/codegen/react-production-policy-v1.md`
- IR 冻结：`specs/external/canonical-external-ir-v1.md`
- 诊断编码：`specs/diagnostics/external-library-diagnostic-codes.md`

## 决策背景

当前 Blueprint 在接入第三方组件库（例如从 esm.sh 动态加载）时，已经暴露出典型扩展性问题：

1. 每接一个组件库都手写一份库专属加载逻辑，调用链路重复、维护成本高。
2. 若强依赖人工 manifest，用户无法快速接入“任意库 + 任意版本”的现实需求。
3. 运行时存在生态差异风险（React 单例、portal 行为、全局 CSS/reset 污染、上下文依赖组件）。
4. 组件库可展示、可拖拽、可渲染、可生成生产代码需要统一协议，不应散落在 UI 侧分支逻辑中。

需要一个可扩展、可降级、可诊断的外部库接入架构，使“无配置可用 + 增强可选”同时成立。

## 决策内容

采用“**Canonical External IR + 通用 Runtime 内核 + 可选 Adapter 增强**”三层架构：

1. **Canonical External IR（事实中间层）**
   - 外部库组件统一映射为稳定节点：`libraryId`、`componentName`、`propsSchema`、`slots`、`behaviorTags`、`codegenHints`。
   - 画布渲染、组件树展示、代码生成均消费 Canonical IR，而不是直接依赖某个库的运行时对象结构。
2. **Runtime 内核统一**
   - 统一负责：远程入口解析、模块加载、导出扫描、组件注册、渲染兜底、诊断上报。
   - 组件库侧只需要提供 `library descriptor`（包名、版本、来源、入口），即可进入标准链路。
3. **Adapter 为可选增强，而非强制前置**
   - 默认通过约定推断即可落地（零配置路径）。
   - 对复杂库或关键组件（如 Modal/Form）再接 Adapter/Manifest 增强，不阻塞基础可用性。

## 术语收敛（2026-02-17 修订）

1. 渲染侧继续使用 Adapter 概念，但对外统一称为 **Render Policy**。
2. 代码生成侧统一称为 **Codegen Policy**，不再使用 “generator adapter” 对外命名。
3. Runtime 与 Codegen 均基于 Canonical IR 扩展，不允许各自维护不可追踪的私有语义。

## 接入分层模型（Manifest 非强制）

### L0：零配置自动发现（必须可用）

1. 从远程模块导出中自动识别 React 组件（命名导出、默认导出、常见静态特征）。
2. 自动生成最小组件定义：名称、默认分组、可透传 props。
3. 注册到组件库面板后即可拖拽到画布，保证“先可用”。

### L1：约定推断增强（默认启用）

1. 基于命名规则和行为标签进行初步分组（Data Entry、Data Display、Feedback、Layout、Navigation）。
2. 推断常见属性枚举并归一化展示（如 size 统一显示 `S/M/L`）。
3. 为组件树和检查器补齐展示名、图标、可编辑属性顺序。

### L2：声明式 Manifest 增强（可选）

1. 仅在需要高质量体验时提供 manifest（分组、属性映射、预置片段、事件语义、代码生成 hints）。
2. Manifest 只做“增量覆盖”，不替代 Runtime 自动发现结果。
3. 缺失 manifest 不会导致组件库不可用。

### L3：Adapter 逻辑增强（可选）

1. 对上下文依赖或副作用强的组件提供专属行为修正（如 Modal/Drawer 的画布安全模式）。
2. 提供渲染包装器、属性转换器、代码生成补丁、诊断规则扩展。
3. Adapter 接口稳定，允许后续接入 Ant Design、Headless UI、Radix、任意 esm.sh 库。

## 标准调用链路

`LibraryDescriptor -> RuntimeLoader -> ExportScanner -> Canonical IR -> Registry.registerGroup -> Palette/Tree/Inspector -> CanvasRenderer -> CodeGenerator`

链路约束：

1. 组件库面板与组件树均以 Canonical IR 为单一来源，不允许各自维护私有解析逻辑。
2. 画布渲染失败必须降级为可解释占位节点，并输出诊断，不得直接崩溃整个编辑器。
3. 代码生成基于 Canonical IR + Codegen Policy hints，确保产物是可生产的静态源码，而非运行时快照。

## 运行时安全与隔离约束

1. **React 单例约束**：外部库必须走统一 React/ReactDOM bridge，避免多 React 实例导致 context/hook 崩溃。
2. **CSS 污染控制**：默认禁止注入全局 reset；仅允许显式通道加载，且可按作用域隔离。
3. **Portal 类组件安全模式**：在画布预览时默认关闭破坏性全屏行为（如强制挂载 body、不可关闭遮罩）。
4. **上下文依赖组件兜底**：Form.Item、Menu.Item 等缺失上层上下文时，自动补最小 provider 或渲染占位提示。

## Diagnostics 标准

定义统一诊断结构：

```ts
type ExternalLibraryDiagnostic = {
  code: string; // ELIB-xxxx
  level: 'info' | 'warning' | 'error';
  stage: 'load' | 'scan' | 'register' | 'render' | 'codegen';
  message: string;
  hint?: string;
  retryable?: boolean;
};
```

规则：

1. 诊断码全局唯一，按阶段分段编码（如 `ELIB-10xx` 加载、`ELIB-20xx` 扫描）。
2. 组件库面板和调试日志显示同一诊断对象，避免信息割裂。
3. 失败必须可观察、可定位、可重试，不使用静默失败。

## 非目标

1. 本阶段不承诺“零配置即完整属性语义”，零配置目标是“可用优先”。
2. 不在本决策内定义第三方库许可扫描与供应链审计流程。
3. 不要求一次性覆盖所有外部库的高级交互模式与可访问性细节。

## 分阶段落地

### Phase 1：通用内核与零配置可用

1. 落地 RuntimeLoader + ExportScanner + Canonical IR 注册链路。
2. 打通组件库面板、组件树、画布三处的一致渲染来源。
3. 输出标准 Diagnostics 并提供 UI 可见错误提示。

### Phase 2：Manifest/Adapter 增量增强

1. 增加 optional manifest 覆盖机制（分组、props 映射、展示名）。
2. 建立 Render Policy / Codegen Policy 接口并完成 `@mdr/ui`、`antd` 最小实现。
3. 为 Modal/Form 等复杂组件补安全渲染策略和代码生成 hints。

### Phase 3：生态化与稳定性

1. 支持用户在项目内注册任意 esm.sh 库并持久化配置。
2. 建立常见库的官方适配包与社区适配模板。
3. 将导入成功率、渲染成功率、代码生成成功率纳入可观测指标。

## 验收标准（Draft）

- [ ] 无 manifest 情况下，任意可解析 React 组件库可在组件库面板出现并可拖拽到画布。
- [ ] 组件树与画布渲染同源，不出现“画布可渲染但组件树缺失”的协议分叉。
- [ ] 外部库加载/渲染失败时，面板可见标准化 Diagnostics，包含阶段与修复提示。
- [ ] 全局样式不因外部库默认加载而被污染（例如 reset.css 不默认接管应用）。
- [ ] 代码生成功能可输出稳定 import 与组件调用，不依赖运行时动态对象结构。
