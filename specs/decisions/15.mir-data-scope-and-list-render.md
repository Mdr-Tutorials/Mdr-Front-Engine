# MIR 数据模型继承与 List 渲染

## 状态

- Draft
- 日期：2026-02-08

## 决策背景

当前 MIR 渲染能力主要依赖：

1. `logic.state` 与 `logic.props`
2. 节点属性中的 `$state/$param` 引用

该能力足以覆盖静态页面与简单交互，但在“数据驱动页面”场景存在明显短板：

1. 组件无法声明“我的子节点绑定到某段 JSON 数据”
2. 缺少低门槛列表渲染机制（把组件模板按数组重复渲染）
3. 父子组件数据上下文不可继承，导致映射配置重复

## 决策内容

在 MIR v1.2 引入两类新语义：

1. `data`：节点级数据模型作用域（data scope）
2. `list`：节点级列表模板渲染（list template render）

并新增引用类型：

1. `$data`：读取当前继承作用域中的字段
2. `$item`：读取 list 当前项字段
3. `$index`：读取 list 当前索引

## 数据作用域模型

`ComponentNode.data` 用于声明当前节点的数据上下文：

1. `source`：切换作用域根（可来自 `$state/$param/$data/$item`）
2. `pick`：从当前作用域下钻子路径（如 `product.detail`）
3. `extend`：派生新字段（用于扁平化和别名）

继承规则：

1. 根节点默认作用域为 `{}`（空对象）
2. 子节点默认继承父作用域
3. 子节点声明 `data` 后，以父作用域为输入，生成新作用域

## List 模板模型

`ComponentNode.list` 用于声明“当前节点作为模板按数组渲染”：

1. `source`：数组来源（必填）
2. `itemAs`：列表项别名（默认 `item`）
3. `indexAs`：索引别名（默认 `index`）
4. `keyBy`：稳定 key 字段（建议）
5. `emptyNodeId`：空态节点引用（可选）

语义：

1. `list` 节点本身为模板，不新增组件类型
2. 每次迭代生成一份该节点子树
3. 迭代上下文向下传递，子节点可使用 `$item/$index`

## 方案对比

### 方案 A：仅增强 `$state/$param`（不引入 data/list）

- 优点：实现最小
- 缺点：映射冗余，列表能力弱，父子上下文无法复用

### 方案 B：允许任意 JS 表达式

- 优点：表达力最强
- 缺点：校验、安全、导出一致性风险高

### 方案 C：显式 data/list 契约（本决策）

- 优点：可校验、可序列化、可导出、对编辑器友好
- 缺点：需要新增渲染器与 Inspector 配置层

## 非目标

1. 不在本 ADR 中定义完整查询语言（如 JSONata）
2. 不引入任意脚本执行
3. 不实现 NodeGraph/动画编辑器 UI

## 迁移策略

1. v1.1 文档保持可读
2. 新建或升级后文档默认输出 v1.2
3. v1.2 字段为向前扩展：不使用 `data/list` 时行为与 v1.1 等价

## 验收标准（Draft）

- [ ] 节点可声明并继承数据作用域
- [ ] 节点可按数组模板渲染
- [ ] `$data/$item/$index` 可在 text/style/props/events.params 中使用
- [ ] 渲染器与导出器对同一文档结果一致
